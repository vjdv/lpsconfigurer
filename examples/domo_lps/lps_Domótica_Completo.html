<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Domótica</title>
</head>
<style>
body{background:#DDD;font:16px Cambria,"Hoefler Text","Liberation Serif",Times,"Times New Roman",serif;}
h1{text-align:center;}
h1,h2{font-family:"Lucida Grande","Lucida Sans Unicode","Lucida Sans","DejaVu Sans",Verdana,sans-serif;}
p{text-align:justify;}
img{max-width:100%;}
a,a:visited{color:#066;text-decoration:none;}
a:hover{color:#077;text-decoration:underline;}
.break{page-break-before:always;}
.contenedor{width:100%;max-width:900px;margin:0 auto;background:#EEE;border-radius:7px;padding:10px;}
.mono{font-family:Consolas, "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", Monaco, "Courier New", monospace}
.chico{font-size:12px;}
.ns,.bu{text-decoration:underline;font-weight:bold;}
.tabla{width:100%;border-collapse:collapse;}
.tabla td, .tabla th{border:1px solid #777;padding:2px 5px 2px 5px;}
.tabla th {padding: 2px 0 2px 0;background-color:#D6D6D6;color:#222;}
</style>
<body>
<div class="contenedor">
<div id="portada">
<h1>Línea de Productos de Software para domótica</h1>
<h2>Ingeniería de aplicación</h2>
<p>La ingeniería de aplicación es la segunda etapa definida en el marco de trabajo empleado para la implementación de líneas de productos de software. En esta etapa se explota las posibilidades de la plataforma y la variabilidad definidas en la ingeniería de dominio, se reutilizan los insumos de dominio tanto como sea posible, se documentan los artefactos de la aplicación (como requerimientos, arquitectura, componentes y pruebas) y se relacionan con los artefactos elaborados en la ingeniería de dominio, se enlaza la variabilidad con los requerimientos de una aplicación para extender la arquitectura, componentes y casos de uso, por último se estima el impacto de las diferencias de los requerimientos de dominio y aplicación en las arquitecturas, componentes y pruebas. El principal objetivo de esta etapa es el desarrollo de un producto específico planeado en la línea de productos de software.</p>
<p>El presente documento ha sido generado a partir de un conjunto de insumos que pertenecen a las fases de análisis de requerimientos, diseño, implementación y pruebas de una línea de productos de software. Ha sido generado automáticamente por un configurador de LPSs que permite capturar toda la información relevante desde una interfaz intuitiva y amigable. El documento ha sido generado el 12 de abril del 2016 a las 02:23:25. Para más información visite la <a href="http://jassiel.vjdv.net/apps/configuradorlps/">página de la aplicación</a>.</p>
</div><!--fin portada-->
<div class="break"/>
<h2>Introducción</h2>
<p>La domótica es el campo donde la casa (<i>domus</i>) se mezcla con la tecnología en distintas formas (informática, así como mecánica, ergonomía y comunicación). Hoy en día muchos de los dispositivos en el hogar se controlan por microprocesadores. La domótica integra dichos dispositivos en una red y de manera inteligente los hace cooperar entre sí para tomar decisiones, controlar su comportamiento y realizar tareas complejas con poca o nula intervención humana.<br><br>Los principales objetivos de la domótica son: comodidad, seguridad, cuidados de salud y reducción de costos. La comodidad se incrementa cuando tareas tediosas se realizan de manera automática o manual desde una interfaz intuitiva y bien diseñada. La seguridad se mejora cuando se cuenta con cámaras de video, alarmas y otras herramientas que permitan tomar acciones rápidas a escenarios de peligro como robos, accesos no permitidos o emergencias. De manera parecida, prevenir otros peligros para la salud humana con detectores de humo, incendios o cortos circuitos. Por último la reducción de costos se logra con administración de energía, como reguladores de calefacción o enfriamiento, luces automáticas y cualquier otra actividad que evite el consumo innecesario de energía.<br>Los dispositivos de una casa inteligente se dividen en dos: sensores y actuadores. Son componentes electrónicos o mecánicos que miden o influencias valores físicos de su ambiente. Los sensores recogen información de su ambiente y la hacen disponible para el sistema (como un sensor infrarrojo que detecta la presencia de una persona en un cuarto). Los actuadores permiten al sistema crear cambios en un ambiente (como interruptores de luces).<br><br>También existen los dispositivos de control inteligentes, que obtienen datos de sensores, procesan la información y activan a los actuadores si es necesario. Un dispositivo de control es responsable solo de una fracción del total de funcionalidades de una casa inteligente (parecido a un subsistema). Aunque este dispositivo actúe de manera autónoma, es necesario que publique la información que obtenga y las decisiones que tome al sistema central.</p>
<h2>Características</h2>
<p>En la siguiente figura se muestra el árbol de características CVL correspondiente al producto:</p>
<div align="center"><a href="Completo_cvl.png"><img src="Completo_cvl.png" alt="Figura 1"><br>Figura 1</a></div><h2>Fase de Requerimientos</h2>
<p>A continuación se describen la definición textual de los requerimientos para el producto.</p>
<p><span class="ns">Objetivos</span><br><span class="mono">G1.1: </span>Ofrecer un sistema de control y automatización de diferentes dispositivos en un hogar.<br><span class="mono">G1.2: </span>Integrar dichos dispositivos en una red y de manera inteligente hacer cooperar sus funciones.<br><span class="mono">G1.3: </span>Controlar el comportamiento de los dispositivos y realizar tareas complejas con poca o nula intervención humana.<br><span class="mono">G1.4: </span>Ofrecer una interfaz vistosa e intuitiva para el usuario final.<br><span class="mono">G1.5: </span>Aumentar la comodidad del usuario en su hogar.<br><span class="mono">G1.6: </span>Mejorar la seguridad al ofrecer herramientas que permitan tomar acciones rápidas a escenarios de peligro.<br><span class="mono">G1.7: </span>Prevenir peligros para la salud humana.<br><span class="mono">G1.8: </span>Reducir los costos al evitar el uso innecesario de recursos que no se estén utilizando.<br><span class="mono">G2: </span>Facilitar el encendido y/o apagado de luces.<br><span class="mono">G3: </span>Conocer si hay presencia de algún individuo en un área determinada.<br><span class="mono">G4: </span>Facilitar el conocimiento de la temperatura de un área.<br><span class="mono">G5: </span>Facilitar el conocimiento de la humedad relativa aproximada de un área.<br><span class="mono">G6: </span>Facilitar el control de televisiones.<br><span class="mono">G7.1: </span>Ofrecer una manera eficaz de crear alarmas y conocer sus eventos.<br><span class="mono">G7.2: </span>Conocer a tiempo eventos que amenacen la seguridad del usuario o del hogar para tomar acciones preventivas o correctivas.<br><span class="mono">G8: </span>Facilitar el control de las cortinas del hogar.<br><span class="mono">G9: </span>Contar con una alarma temprana que permita conocer si se genera fuego en un área específica para atender el siniestro antes de que ocurran daños mayores.<br><span class="mono">G10: </span>Contar con una alarma temprana que permita conocer en un área hay concentraciones peligrosas de gases como monóxido de carbono, dióxido de carbono, gas LP, butano, metano, etcétera; y atender la causa.<br><span class="mono">G20: </span>Ofrecer un dispositivo de control de ciertas características a través de un microcontrolador Arduino programado por la empresa Rodas.<br><span class="mono">G21: </span>Controlar una luz a través de relevadores con el microcontrolador Arduino.<br><span class="mono">G22: </span>Conocer la presencia (o ausencia) de personas en un área a través de un Arduino.<br><span class="mono">G23: </span>Conocer la temperatura de un área específica a través de un Arduino.<br><span class="mono">G30: </span>Ofrecer un conjunto de soluciones que satisfagan ciertas características de un ambiente domótico, esto a través de una Raspberry Pi, que gracias a su poder de procesamiento es capaz de encargarse de distintos dispositivos, distintas áreas y soló con un dispositivo.<br><span class="mono">G40: </span>Ofrecer un conjunto de soluciones que satisfagan ciertas características de un ambiente domótico, esto a través de un microcontrolador NodeMCU Lua ESP8266, este dispositivo incluye funciones parecidas a un Arduino e incorpora un chip ESP12 que permite su conexión con redes WiFi, ideal para el internet de las cosas.<br><span class="ns">Rasgos deseados</span><br><span class="mono">F1: </span>Control de los dispositivos del hogar.<br><span class="mono">F2: </span>Control de luces.<br><span class="mono">F3: </span>Lectura de presencia.<br><span class="mono">F4: </span>Lectura de temperatura.<br><span class="mono">F5: </span>Lectura de humedad relativa.<br><span class="mono">F6: </span>Control de TV's.<br><span class="mono">F7: </span>Activación de alarmas.<br><span class="mono">F8: </span>Control de cortinas.<br><span class="mono">F9: </span>Generar alarmas de fuego.<br><span class="mono">F10: </span>Generar alarmas de gases peligrosos.<br><span class="mono">F20: </span>Control de diversos dispositivos a través de un controlador Arduino programado por la empresa Rodas.<br><span class="mono">F21: </span>Control de una luz a través de un Arduino.<br><span class="mono">F22: </span>Lectura de presencia a través de un Arduino.<br><span class="mono">F23: </span>Lectura de temperatura a través de un Arduino.<br><span class="mono">F30: </span>Control de diversos dispositivos a través de una Raspberry Pi programada por uno mismo.<br><span class="mono">F31: </span>Control de luces a través de una Raspberry Pi.<br><span class="mono">F32: </span>Conocer la presencia (o ausencia) de personas en un área a través de una Raspberry Pi.<br><span class="mono">F33: </span>Obtención de la temperatura de un área a través de una Raspberry Pi.<br><span class="mono">F34: </span>Obtención de la humedad relativa de un área a través de una Raspberry Pi.<br><span class="mono">F35: </span>Control de una o más televisiones a través de una Raspberry Pi.<br><span class="mono">F40: </span>Control de diversos dispositivos a través de un microcontrolador NodeMCU ESP8266 programado por uno mismo.<br><span class="ns">Requerimientos</span><br><span class="mono">R1: </span>El sistema debe tener una arquitectura fácilmente escalable y flexible que permita agregar diferentes abstracciones de dispositivos domóticos como convenga.<br><span class="mono">R2.1: </span>El servidor incluirá clases abstractas que representen una luz, de la cual extenderán las clases que implementen un dispositivo de luz concreto.<br><span class="mono">R2.2: </span>La luz se marcará como "No disponible" cuando el servidor falle al contactar el dispositivo de luz o el dispositivo retorne respuestas no válidas.<br><span class="mono">R2.3: </span>Las aplicaciones cliente mostrarán (por cada luz) un ícono que permita identificar que se trata de una luz, una etiqueta que indique el número de luz y un botón conmutable para encender o apagar la luz.<br><span class="mono">R3.1: </span>El servidor incluirá clases abstractas que representen la ausencia o presencia de una persona en un área, de la cual extenderán las clases que implementen un dispositivo sensor de presencia concreto.<br><span class="mono">R3.2: </span>Las aplicaciones cliente mostrarán (por cada dispositivo de presencia) un ícono que permita identificar el tipo de dispositivo, una etiqueta que indique su tipo y número y otra etiqueta más que muestre el valor actual de la lectura.<br><span class="mono">R3.3: </span>El dispositivo sensor de presencia se marcará como "No disponible" cuando el servidor falle al contactar el dispositivo o el dispositivo retorne respuestas no válidas.<br><span class="mono">R4.1: </span>El servidor incluirá clases abstractas que representen la ponderación de la temperatura de un área, de la cual extenderán las clases que implementen un dispositivo sensor de temperatura concreto.<br><span class="mono">R4.2: </span>Las aplicaciones cliente mostrarán (por cada dispositivo sensor de temperatura) un ícono que permita identificar el tipo de dispositivo, una etiqueta que indique su tipo y número y otra etiqueta más que muestre el valor actual de la temperatura.<br><span class="mono">R4.3: </span>El sensor de temperatura se debe marcar como "No disponible" cuando el servidor no logre contactar al dispositivo u obtenga una respuesta no válida.<br><span class="mono">R5.1: </span>El servidor incluirá clases abstractas que representen la ponderación de la humedad relativa de un área, de la cual extenderán las clases que implementen un dispositivo sensor de humedad concreto.<br><span class="mono">R5.2: </span>Las aplicaciones cliente mostrarán (por cada dispositivo sensor de humedad) un ícono que permita identificar el tipo de dispositivo, una etiqueta que indique su tipo y número y otra etiqueta más que muestre el valor actual de la humedad relativa.<br><span class="mono">R5.3: </span>El sensor de humedad se debe marcar como "No disponible" cuando el servidor no logre contactar al dispositivo u obtenga una respuesta no válida.<br><span class="mono">R6.1: </span>El servidor incluirá clases abstractas que representen una televisión del hogar, de la cuál extenderán las clases que implementen el control concreto de una televisión específica.<br><span class="mono">R6.2: </span>El servidor incluirá clases abstractas que representen las operaciones básicas a ejecutar sobre una televisión, como encenderla y apagarla, cambiar de canal o presionar una tecla de un control remoto.<br><span class="mono">R6.3: </span>La televisión se marcará como "No disponible" cuando el servidor falle al contactar el dispositivo que controle la televisión o el dispositivo retorne respuestas no válidas.<br><span class="mono">R6.4: </span>Las aplicaciones cliente mostrarán (por cada televisión) un ícono que permita identificar el tipo de dispositivo, una etiqueta que indique su tipo y número y un botón que permita mostrar u ocultar los controles adicionales (las teclas del control, por ejemplo).<br><span class="mono">R7.1: </span>El servidor incluirá clases abstractas que representen una alarma cualquiera, de la cual extenderán las clases que implementen un dispositivo de alarma concreto.<br><span class="mono">R7.2: </span>La alarma se marcará como "No disponible" cuando el servidor falle al contactar el dispositivo de alarma o el dispositivo retorne respuestas no válidas.<br><span class="mono">R7.3: </span>Al generarse un evento en una alarma, este debe guardarse en una bitácora para posterior consulta o análisis.<br><span class="mono">R7.4: </span>Al generarse un evento de alarma, el servidor debe avisar a la mayor brevedad posible a los clientes conectados.<br><span class="mono">R7.5: </span>Las aplicaciones cliente mostrarán (por cada alarma) un ícono que permita identificar el tipo de dispositivo, una etiqueta que indique su tipo y número y otra etiqueta más que muestre el valor actual que la alarma represente.<br><span class="mono">R7.6: </span>Los clientes conectados al servidor, al recibir un evento de alarma, deben ejecutar algún mecanismo (un sonido, un mensaje SMS, por ejemplo) que permita al usuario conocer lo más pronto posible la situación y este sea capaz de realizar alguna acción preventiva o correctiva si se requiere.<br><span class="mono">R8.1: </span>El servidor incluirá clases abstractas que permitan representar una cortina, de la cual extenderán las clases que implementen un dispositivo de control de cortina concreto.<br><span class="mono">R8.2: </span>La cortina se marcará como "No disponible" cuando el servidor falle al contactar el dispositivo de cortina o el dispositivo retorne respuestas no válidas.<br><span class="mono">R8.3: </span>Las aplicaciones cliente mostrarán (por cada cortina) un ícono que permita identificar al dispositivo, una etiqueta que indique el número de cortina y un botón deslizable para cambiar la posición de la cortina.<br><span class="mono">R9.1: </span>El servidor incluirá clases que especialicen las clases de la característica <i>alarma</i> y permita diferenciar una alarma de fuego.<br><span class="mono">R9.2: </span>Las aplicaciones cliente contarán con un ícono personalizado para la alarma de tipo fuego.<br><span class="mono">R10.1: </span>El servidor incluirá clases que especialicen las clases de la característica <i>alarma</i> y permita diferenciar una alarma de gases peligrosos.<br><span class="mono">R10.2: </span>Las aplicaciones cliente contarán con un ícono personalizado para la alarma de gases peligrosos.<br><span class="mono">R20: </span>El servidor domótico agregará las clases necesarias para conectarse a un dispositivo Arduino programado por la empresa Rodas y utilizar sus recursos.<br><span class="mono">R22: </span>El servidor domótico agregará la implementación de un sensor de presencia y actualizará su estado al enviar el comando <i>GET /PIR</i> al dispositivo Arduino de Rodas y obtener respuesta.<br><span class="mono">R23: </span>El servidor domótico agregará la implementación de un sensor de temperatura y actualizará su estado al enviar el comando <i>GET /TEMP</i> al dispositivo Arduino de Rodas y obtener respuesta.<br><span class="mono">R30.1: </span>Programar un servidor TCP/IP en la(s) Raspberry Pi sobre el puerto 8585 (recomendado) para lograr la comunicación con el dispositivo.<br><span class="mono">R30.2: </span>Tener la capacidad de instalar más de un servidor TCP/IP sobre puertos diferentes para simular control de áreas distintas con una misma Raspberry Pi.<br><span class="mono">R30.3: </span>El servidor TCP/IP de la Raspberry Pi debe aceptar comandos del tipo <i>SET KEY = VALUE</i> para realizar cambios de estado en los dispositivos.<br><span class="mono">R30.4: </span>El servidor TCP/IP de la Raspberry Pi debe aceptar comandos del tipo <i>GET KEY</i> para obtener los valores de un dispositivo o sensor específico.<br><span class="mono">R30.5: </span>El servidor TCP/IP de la Raspberry Pi debe devolver el estado de todos los dispositivos que maneja al enviársele el comando <i>GET ALL</i>.<br><span class="mono">R30.6: </span>El formato de las respuestas que la Raspberry debe enviar al pedírseles datos, debe tener el siguiente formato: <i>#KEY1|VALUE1|KEY2|VALUE2|KEYn|VALUEn#</i><br><span class="mono">R30.7: </span>La Raspberry Pi debe mantener la conexión abierta y avisar de cambios de estado en los dispositivos en tiempo real en el mismo formato especificado.<br><span class="mono">R30.8: </span>Después de que el servidor de domótica envíe un comando o el servidor de la Raspberry dé una respuesta, se debe incluir un salto de línea al final.<br><span class="mono">R30.9: </span>La Raspberry Pi debe se capaz de controlar más de un dispositivo del mismo tipo, enumerándolos (opcionalmente si sólo es uno) del 1 al 9.<br><span class="mono">R31.1: </span>La Raspberry Pi debe ser capaz de controlar una o más luces, sin importar el mecanismo (transistores, mosfets o relevadores, etcétera).<br><span class="mono">R31.2: </span>Las respuestas para los estados de luz debe basarse en los siguientes ejemplos: #LUZ1|ON|LUZ2OFF|LUZn|VALUE#<br><span class="mono">R31.3: </span>El comando para cambiar el estado de una luz puede aceptar los valores ON o 1 para encender y OFF o 0 para apagar. Ejemplo: SET LUZ1 = ON ó SET LUZ1 = 1<br><span class="mono">R32.1: </span>La Raspberry Pi debe ser capaz de poder leer el estado de uno o más sensores de presencia.<br><span class="mono">R32.2: </span>Las respuestas para los estados de sensores de presencia de la Raspberry Pi se basa en los siguientes ejemplos #PIR|SI|PIRn|NO#<br><span class="mono">R33.1: </span>La Raspberry Pi debe ser capaz de poder leer el estado de uno o más sensores de temperatura.<br><span class="mono">R33.2: </span>Las respuestas para los estados de sensores de temperatura de la Raspberry Pi se basa en los siguientes ejemplos #TEMP|33.1|TEMPn|27.5#<br><span class="mono">R34.1: </span>La Raspberry Pi debe ser capaz de poder leer el estado de uno o más sensores de humedad.<br><span class="mono">R34.2: </span>Las respuestas para los estados de sensores de humedad de la Raspberry Pi se basa en los siguientes ejemplos #HUMD|58.6|HUMDn|75.6#<br><span class="mono">R35.1: </span>La Raspberry Pi debe tener la librería LIRC habilitada y configurada para el envío de comandos a televisiones a través de diodos infrarrojos.<br><span class="mono">R35.2: </span>La Raspberry Pi debe tener un servidor especial para el control de televisiones basado en el estándar REST.<br><span class="mono">R35.3: </span>Las peticiones HTTP para simular la presión de una tecla de un control remoto de una televisión, se enviarán a la Raspberry haciendo peticiones a la URL http://ip-raspberry/KEY/tecla_a_enviar<br><span class="mono">R35.4: </span>Las peticiones HTTP para solicitar un canal se enviarán a la Raspberry haciendo peticiones a la URL http://ip-raspberry/CHANNEL/número_canal<br><span class="mono">R37.3: </span>El dispositivo aceptará los comandos <i>get position</i> y devolverá una cadena con el formato <i>#position|[valor]#</i> donde valor será un número entero del 0 al 100 que indica la posición actual de la cortina.<br><span class="mono">R40.1: </span>Los dispositivos NodeMCU tendrán un servidor TCP/IP que permita al servidor domótico interactuar con él y realizar operaciones o leer valores que se requieran.<br><span class="mono">R40.2: </span>El servidor domótico incluirá clientes específicos para cada tipo de controlador Nodepi (dispositivo NodeMCU) y agregar las clases necesarias para hacer la abstracción.<br><span class="mono">R43: </span>El servidor domótico creará una implementación de un sensor de humedad y actualizará su estado cada vez que la cadena retornada por el dispositivo NodeMCU contenga la clave <i>humd</i>.<br><span class="mono">R44: </span>El servidor domótico creará una implementación de un sensor de temperatura y actualizará su estado cada vez que la cadena retornada por el dispositivo NodeMCU contenga la clave <i>temp</i>.<br><span class="mono">R46: </span>El servidor domótico creará una implementación de una alarma de gases peligrosos y actualizará su estado cada vez que la cadena retornada por el dispositivo NodeMCU contenga la clave <i>gas_ana</i> o <i>gas_dig</i>.<br><span class="mono">R47.1: </span>Un dispositivo NodeMCU será programado especialmente para el control de cortinas a través de un motor de paso por paso, esto sobre el protocolo TCP/IP <br><span class="mono">R47.2: </span>El dispositivo aceptará los comandos <i>set position [valor]</i> donde valor será un número entero del 0 al 100 para indicar la posición requerida de la cortina.<br><span class="mono">R47.3: </span>El servidor domótico creará una implementación de una cortina y actualizará su estado cada cinco minutos para conocer la posición actual de la cortina en caso de que haya sido controlada manualmente.<br><span class="mono">R47.4: </span>El dispositivo aceptará comando adicionales que permitan configurarlo adecuadamente a cualquier tamaño de ventana, como cambiar la posición inicial y posición maxima.</p>
<h2>Fase de diseño</h2>
<p>Diagramas de clases de la aplicación</p>
<div align="center"><a href="Completo_nghA5vKGAqACQAmA_ddc.png"><img src="Completo_nghA5vKGAqACQAmA_ddc.png" alt="Figura 2"><br>Figura 2</a></div><div align="center"><a href="Completo_ODYG5vKGAqACQAi2_ddc.png"><img src="Completo_ODYG5vKGAqACQAi2_ddc.png" alt="Figura 3"><br>Figura 3</a></div><h2>Fase de Pruebas</h2>
<p>Pruebas pertenecientes a la aplicación</p>
<table class="tabla" align="center"><tr><th>ID</th><th>Descripción u Objetivo</th><th>Pre-requisitos</th><th>Datos de entrada</th><th>Datos de salida</th></tr><tr><td class="mono">1.1</td><td>Probar diversos métodos de la plataforma para validar las pruebas unitarias.</td><td>Incluir la plataforma de referencia.</td><td>Datos <i>dummy</i> según el método y clase.</td><td>Depende del método.</td></tr><tr><td class="mono">1.2</td><td>Probar la conexión a la base de datos.</td><td>Tener datos de conexión configurados previamente.</td><td>Servidor, usuario y contraseña.</td><td>Conexión realizada con éxito.</td></tr><tr><td class="mono">1.3</td><td>Comprobar que se están obteniendo correctamente los controladores registrados en la base de datos y están siendo instanciados.</td><td>Tener algunos controladores en la base de datos.</td><td>Ninguno.</td><td>Instancias de objetos.</td></tr><tr><td class="mono">1.4</td><td>Iniciar los servicios del servidor de domótica.</td><td>Tener ya una configuración del servidor.</td><td>Ninguno.</td><td>Éxito al iniciar servicios.</td></tr><tr><td class="mono">1.5</td><td>Comprobar que el servidor impida el acceso no autorizado.</td><td>Tener algunos usuarios en la base de datos.</td><td>Definidos en prueba.</td><td>Acceso denegado en todos los intentos.</td></tr><tr><td class="mono">1.6</td><td>Comprobar que el servidor acepte accesos autorizados.</td><td>Tener al menos un usuario en la base de datos.</td><td>Usuario y contraseña.</td><td>Acceso consedido y token.</td></tr><tr><td class="mono">3.1</td><td>Probar la conexión con una Raspberry Pi. Según el protocolo establecido, para enviar un comando se necesita enviar una cadena del tipo <i>GET [dispositivo]</i> ó <i>SET [dispositivo] [estado]</i> finalizando con un salto de línea. La respuesta llegará en una nueva línea con el formato <i>#KEYn|VALUEn#</i>.</td><td>Tener una Raspberry Pi conectada a la red, conocer su IP y que esté ejecutando el programa de Domopi.</td><td>IP de la Raspberry Pi
Enviar comando GET ALL</td><td>Conexión realizada y respuesta obtenida.</td></tr></table>
<h2>Ejecución de Pruebas</h2>
<p>Pruebas pertenecientes a la aplicación</p>
<table class="tabla" align="center"><tr><th>ID</th><th>Descripción u Objetivo</th><th>Información de ejecución</th><th>Éxito</th></tr><tr><td class="mono">1.1</td><td>Probar diversos métodos de la plataforma para validar las pruebas unitarias.</td><td class="mono chico"></td><td>No</td></tr><tr><td class="mono">1.2</td><td>Probar la conexión a la base de datos.</td><td class="mono chico"></td><td>No</td></tr><tr><td class="mono">1.3</td><td>Comprobar que se están obteniendo correctamente los controladores registrados en la base de datos y están siendo instanciados.</td><td class="mono chico"></td><td>No</td></tr><tr><td class="mono">1.4</td><td>Iniciar los servicios del servidor de domótica.</td><td class="mono chico"></td><td>No</td></tr><tr><td class="mono">1.5</td><td>Comprobar que el servidor impida el acceso no autorizado.</td><td class="mono chico"></td><td>No</td></tr><tr><td class="mono">1.6</td><td>Comprobar que el servidor acepte accesos autorizados.</td><td class="mono chico">abr 12, 2016 2:23:26 AM com.intelidomo.configurador.PrincipalController$Exporter ejecutarPrueba<br>GRAVE: La clase no tiene método main, no es posible ejecutar la prueba.<br>abr 12, 2016 2:23:26 AM intelidomo.pruebas.BaseDatos main<br>INFORMACIÓN: Cargando clase Gestor.<br>abr 12, 2016 2:23:27 AM com.intelidomo.configurador.PrincipalController$Exporter ejecutarPrueba<br>GRAVE: Error inesperado al ejecutar prueba<br>java.lang.reflect.InvocationTargetException<br>&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:497)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.ejecutarPrueba(PrincipalController.java:1212)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.lambda$exportarAplicacion$64(PrincipalController.java:1165)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter$$Lambda$565/2007645070.accept(Unknown Source)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)<br>&nbsp;&nbsp;at java.util.stream.SortedOps$RefSortingSink$$Lambda$539/1474434377.accept(Unknown Source)<br>&nbsp;&nbsp;at java.util.ArrayList.forEach(ArrayList.java:1249)<br>&nbsp;&nbsp;at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:390)<br>&nbsp;&nbsp;at java.util.stream.Sink$ChainedReference.end(Sink.java:258)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)<br>&nbsp;&nbsp;at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.exportarAplicacion(PrincipalController.java:1165)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.call(PrincipalController.java:868)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.call(PrincipalController.java:816)<br>&nbsp;&nbsp;at javafx.concurrent.Task$TaskCallable.call(Task.java:1423)<br>&nbsp;&nbsp;at java.util.concurrent.FutureTask.run(FutureTask.java:266)<br>&nbsp;&nbsp;at java.lang.Thread.run(Thread.java:745)<br>Caused by: java.lang.ClassNotFoundException: /db/Gestor<br>&nbsp;&nbsp;at java.lang.Class.forName0(Native Method)<br>&nbsp;&nbsp;at java.lang.Class.forName(Class.java:264)<br>&nbsp;&nbsp;at intelidomo.pruebas.BaseDatos.main(BaseDatos.java:14)<br>&nbsp;&nbsp;... 24 more<br><br>abr 12, 2016 2:23:27 AM intelidomo.pruebas.ObtenerControladores main<br>INFORMACIÓN: Cargando clase Gestor y conectando.<br>abr 12, 2016 2:23:27 AM com.intelidomo.configurador.PrincipalController$Exporter ejecutarPrueba<br>GRAVE: Error inesperado al ejecutar prueba<br>java.lang.reflect.InvocationTargetException<br>&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:497)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.ejecutarPrueba(PrincipalController.java:1212)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.lambda$exportarAplicacion$64(PrincipalController.java:1165)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter$$Lambda$565/2007645070.accept(Unknown Source)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)<br>&nbsp;&nbsp;at java.util.stream.SortedOps$RefSortingSink$$Lambda$539/1474434377.accept(Unknown Source)<br>&nbsp;&nbsp;at java.util.ArrayList.forEach(ArrayList.java:1249)<br>&nbsp;&nbsp;at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:390)<br>&nbsp;&nbsp;at java.util.stream.Sink$ChainedReference.end(Sink.java:258)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)<br>&nbsp;&nbsp;at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.exportarAplicacion(PrincipalController.java:1165)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.call(PrincipalController.java:868)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.call(PrincipalController.java:816)<br>&nbsp;&nbsp;at javafx.concurrent.Task$TaskCallable.call(Task.java:1423)<br>&nbsp;&nbsp;at java.util.concurrent.FutureTask.run(FutureTask.java:266)<br>&nbsp;&nbsp;at java.lang.Thread.run(Thread.java:745)<br>Caused by: java.lang.ClassNotFoundException: /db/Gestor<br>&nbsp;&nbsp;at java.lang.Class.forName0(Native Method)<br>&nbsp;&nbsp;at java.lang.Class.forName(Class.java:264)<br>&nbsp;&nbsp;at intelidomo.pruebas.ObtenerControladores.main(ObtenerControladores.java:15)<br>&nbsp;&nbsp;... 24 more<br><br>abr 12, 2016 2:23:27 AM intelidomo.pruebas.InicioServidor main<br>INFORMACIÓN: Cargando clase de inicio de producto.<br>abr 12, 2016 2:23:27 AM com.intelidomo.configurador.PrincipalController$Exporter ejecutarPrueba<br>GRAVE: Error inesperado al ejecutar prueba<br>java.lang.reflect.InvocationTargetException<br>&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:497)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.ejecutarPrueba(PrincipalController.java:1212)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.lambda$exportarAplicacion$64(PrincipalController.java:1165)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter$$Lambda$565/2007645070.accept(Unknown Source)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)<br>&nbsp;&nbsp;at java.util.stream.SortedOps$RefSortingSink$$Lambda$539/1474434377.accept(Unknown Source)<br>&nbsp;&nbsp;at java.util.ArrayList.forEach(ArrayList.java:1249)<br>&nbsp;&nbsp;at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:390)<br>&nbsp;&nbsp;at java.util.stream.Sink$ChainedReference.end(Sink.java:258)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)<br>&nbsp;&nbsp;at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)<br>&nbsp;&nbsp;at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)<br>&nbsp;&nbsp;at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.exportarAplicacion(PrincipalController.java:1165)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.call(PrincipalController.java:868)<br>&nbsp;&nbsp;at com.intelidomo.configurador.PrincipalController$Exporter.call(PrincipalController.java:816)<br>&nbsp;&nbsp;at javafx.concurrent.Task$TaskCallable.call(Task.java:1423)<br>&nbsp;&nbsp;at java.util.concurrent.FutureTask.run(FutureTask.java:266)<br>&nbsp;&nbsp;at java.lang.Thread.run(Thread.java:745)<br>Caused by: java.lang.ClassNotFoundException: /aplicacion/Inicio<br>&nbsp;&nbsp;at java.lang.Class.forName0(Native Method)<br>&nbsp;&nbsp;at java.lang.Class.forName(Class.java:264)<br>&nbsp;&nbsp;at intelidomo.pruebas.InicioServidor.main(InicioServidor.java:13)<br>&nbsp;&nbsp;... 24 more<br><br>abr 12, 2016 2:23:27 AM com.intelidomo.configurador.PrincipalController$Exporter ejecutarPrueba<br>GRAVE: La clase no tiene método main, no es posible ejecutar la prueba.<br>abr 12, 2016 2:23:27 AM com.intelidomo.configurador.PrincipalController$Exporter ejecutarPrueba<br>GRAVE: La clase no tiene método main, no es posible ejecutar la prueba.<br></td><td>No</td></tr></table>
</div><!--fin contenedor-->
</body>
</html>